#!/usr/bin/env python3
"""
LaTeX Compilation Script - Unified compiler for pdflatex/xelatex/lualatex

Usage:
    python compile.py main.tex                       # Auto-detect compiler
    python compile.py main.tex --compiler xelatex    # Explicit compiler
    python compile.py main.tex --recipe xelatex-bibtex  # Use recipe
    python compile.py main.tex --watch               # Continuous compilation
    python compile.py main.tex --clean               # Clean auxiliary files

Recipes (matching VS Code LaTeX Workshop):
    xelatex          - XeLaTeX only
    pdflatex         - PDFLaTeX only
    latexmk          - LaTeXmk auto
    xelatex-bibtex   - xelatex -> bibtex -> xelatex*2
    xelatex-biber    - xelatex -> biber -> xelatex*2
    pdflatex-bibtex  - pdflatex -> bibtex -> pdflatex*2
    pdflatex-biber   - pdflatex -> biber -> pdflatex*2
"""

import argparse
import os
import re
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import List, Optional, Tuple


class LaTeXCompiler:
    """Unified LaTeX compilation with multiple recipes."""

    COMPILERS = {
        'pdflatex': ['-pdf', '-pdflatex=pdflatex -interaction=nonstopmode -shell-escape %O %S'],
        'xelatex': ['-xelatex', '-pdfxe', '-xelatex=xelatex -interaction=nonstopmode -shell-escape %O %S'],
        'lualatex': ['-lualatex', '-pdflua', '-lualatex=lualatex -interaction=nonstopmode -shell-escape %O %S'],
    }

    # Recipes matching VS Code LaTeX Workshop configuration
    RECIPES = {
        'xelatex': ['xelatex'],
        'pdflatex': ['pdflatex'],
        'bibtex': ['bibtex'],
        'biber': ['biber'],
        'latexmk': ['latexmk'],
        'xelatex-bibtex': ['xelatex', 'bibtex', 'xelatex', 'xelatex'],
        'xelatex-biber': ['xelatex', 'biber', 'xelatex', 'xelatex'],
        'pdflatex-bibtex': ['pdflatex', 'bibtex', 'pdflatex', 'pdflatex'],
        'pdflatex-biber': ['pdflatex', 'biber', 'pdflatex', 'pdflatex'],
    }

    # Patterns indicating Chinese content
    CHINESE_PATTERNS = [
        r'\\usepackage.*{ctex}',
        r'\\usepackage.*{xeCJK}',
        r'\\documentclass.*{ctexart}',
        r'\\documentclass.*{ctexbook}',
        r'\\documentclass.*{ctexrep}',
        r'\\documentclass.*{thuthesis}',
        r'\\documentclass.*{pkuthss}',
        r'\\documentclass.*{ustcthesis}',
        r'\\documentclass.*{fduthesis}',
        r'[\u4e00-\u9fff]',  # Chinese characters
    ]

    def __init__(self, tex_file: str, compiler: Optional[str] = None, recipe: Optional[str] = None):
        self.tex_file = Path(tex_file).resolve()
        self.work_dir = self.tex_file.parent
        self.compiler = compiler or self._detect_compiler()
        self.recipe = recipe

    def _detect_compiler(self) -> str:
        """Auto-detect appropriate compiler based on document content."""
        try:
            content = self.tex_file.read_text(encoding='utf-8', errors='ignore')
        except Exception:
            return 'pdflatex'  # Default fallback

        # Check for Chinese content
        for pattern in self.CHINESE_PATTERNS:
            if re.search(pattern, content):
                print(f"[INFO] Detected Chinese content, using xelatex")
                return 'xelatex'

        # Check for explicit engine specification
        if re.search(r'%\s*!TEX\s+program\s*=\s*xelatex', content, re.IGNORECASE):
            return 'xelatex'
        if re.search(r'%\s*!TEX\s+program\s*=\s*lualatex', content, re.IGNORECASE):
            return 'lualatex'
        if re.search(r'%\s*!TEX\s+program\s*=\s*pdflatex', content, re.IGNORECASE):
            return 'pdflatex'

        # Check for fontspec (requires xelatex or lualatex)
        if re.search(r'\\usepackage.*{fontspec}', content):
            print(f"[INFO] Detected fontspec package, using xelatex")
            return 'xelatex'

        return 'pdflatex'

    def _check_tools(self) -> Tuple[bool, str]:
        """Check if required tools are available."""
        # Check latexmk
        if not shutil.which('latexmk'):
            return False, "latexmk not found. Install TeX Live or MiKTeX."

        # Check selected compiler
        compiler_cmd = self.compiler
        if not shutil.which(compiler_cmd):
            return False, f"{compiler_cmd} not found. Install TeX Live or MiKTeX."

        return True, "All tools available"

    def compile(self, watch: bool = False, biber: bool = False) -> int:
        """
        Compile the LaTeX document.

        Args:
            watch: Enable continuous compilation mode
            biber: Use biber instead of bibtex

        Returns:
            Exit code (0 for success)
        """
        # Check tools
        ok, msg = self._check_tools()
        if not ok:
            print(f"[ERROR] {msg}")
            return 1

        # If recipe is specified, use recipe-based compilation
        if self.recipe:
            return self._compile_with_recipe()

        print(f"[INFO] Compiling {self.tex_file.name} with {self.compiler}")
        print(f"[INFO] Working directory: {self.work_dir}")

        # Build latexmk command
        cmd = ['latexmk']

        # Add compiler-specific options
        if self.compiler in self.COMPILERS:
            cmd.extend(self.COMPILERS[self.compiler])
        else:
            cmd.append('-pdf')

        # Add common options
        cmd.extend([
            '-interaction=nonstopmode',
            '-file-line-error',
            '-synctex=1',
        ])

        # Biber support
        if biber:
            cmd.append('-bibtex')

        # Watch mode
        if watch:
            cmd.append('-pvc')
            print("[INFO] Watch mode enabled. Press Ctrl+C to stop.")

        # Add input file
        cmd.append(str(self.tex_file))

        # Run compilation
        try:
            result = subprocess.run(
                cmd,
                cwd=self.work_dir,
                capture_output=False,
            )
            if result.returncode == 0:
                pdf_file = self.tex_file.with_suffix('.pdf')
                print(f"\n[SUCCESS] PDF generated: {pdf_file}")
            else:
                print(f"\n[ERROR] Compilation failed with exit code {result.returncode}")
            return result.returncode

        except KeyboardInterrupt:
            print("\n[INFO] Compilation stopped by user")
            return 0
        except Exception as e:
            print(f"[ERROR] {e}")
            return 1

    def _compile_with_recipe(self) -> int:
        """Compile using a predefined recipe (VS Code LaTeX Workshop style)."""
        if self.recipe not in self.RECIPES:
            print(f"[ERROR] Unknown recipe: {self.recipe}")
            print(f"[INFO] Available recipes: {', '.join(self.RECIPES.keys())}")
            return 1

        steps = self.RECIPES[self.recipe]
        print(f"[INFO] Using recipe: {self.recipe}")
        print(f"[INFO] Steps: {' -> '.join(steps)}")
        print(f"[INFO] Working directory: {self.work_dir}")

        tex_base = self.tex_file.stem

        for i, step in enumerate(steps, 1):
            print(f"\n[STEP {i}/{len(steps)}] Running {step}...")

            if step == 'latexmk':
                cmd = ['latexmk', '-pdf', '-interaction=nonstopmode',
                       '-synctex=1', str(self.tex_file)]
            elif step in ('pdflatex', 'xelatex', 'lualatex'):
                cmd = [step, '-interaction=nonstopmode', '-shell-escape',
                       '-synctex=1', str(self.tex_file)]
            elif step == 'bibtex':
                cmd = ['bibtex', tex_base]
            elif step == 'biber':
                cmd = ['biber', tex_base]
            else:
                print(f"[ERROR] Unknown step: {step}")
                return 1

            try:
                result = subprocess.run(
                    cmd,
                    cwd=self.work_dir,
                    capture_output=False,
                )
                if result.returncode != 0:
                    # bibtex/biber may return non-zero for warnings, continue anyway
                    if step not in ('bibtex', 'biber'):
                        print(f"[ERROR] Step {step} failed with exit code {result.returncode}")
                        return result.returncode
                    else:
                        print(f"[WARNING] {step} returned {result.returncode}, continuing...")

            except FileNotFoundError:
                print(f"[ERROR] {step} not found. Please install it.")
                return 1
            except Exception as e:
                print(f"[ERROR] {e}")
                return 1

        pdf_file = self.tex_file.with_suffix('.pdf')
        if pdf_file.exists():
            print(f"\n[SUCCESS] PDF generated: {pdf_file}")
            return 0
        else:
            print(f"\n[ERROR] PDF not found: {pdf_file}")
            return 1

    def clean(self, full: bool = False) -> int:
        """
        Clean auxiliary files.

        Args:
            full: Also remove output PDF

        Returns:
            Exit code (0 for success)
        """
        print(f"[INFO] Cleaning auxiliary files in {self.work_dir}")

        cmd = ['latexmk', '-c']
        if full:
            cmd = ['latexmk', '-C']

        cmd.append(str(self.tex_file))

        try:
            result = subprocess.run(cmd, cwd=self.work_dir, capture_output=True)
            if result.returncode == 0:
                print("[SUCCESS] Auxiliary files cleaned")
            return result.returncode
        except Exception as e:
            print(f"[ERROR] {e}")
            return 1


def main():
    parser = argparse.ArgumentParser(
        description='LaTeX Compilation Script - Unified compiler for pdflatex/xelatex/lualatex',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Recipes (matching VS Code LaTeX Workshop):
  xelatex          XeLaTeX only
  pdflatex         PDFLaTeX only
  latexmk          LaTeXmk auto
  xelatex-bibtex   xelatex -> bibtex -> xelatex*2
  xelatex-biber    xelatex -> biber -> xelatex*2
  pdflatex-bibtex  pdflatex -> bibtex -> pdflatex*2
  pdflatex-biber   pdflatex -> biber -> pdflatex*2

Examples:
  python compile.py main.tex                        # Auto-detect
  python compile.py main.tex --recipe xelatex-biber # Full workflow
  python compile.py main.tex --watch                # Watch mode
        """
    )
    parser.add_argument('tex_file', help='Main .tex file to compile')
    parser.add_argument(
        '--compiler', '-c',
        choices=['pdflatex', 'xelatex', 'lualatex'],
        help='Compiler to use (auto-detected if not specified)'
    )
    parser.add_argument(
        '--recipe', '-r',
        choices=['xelatex', 'pdflatex', 'latexmk', 'xelatex-bibtex',
                 'xelatex-biber', 'pdflatex-bibtex', 'pdflatex-biber'],
        help='Use predefined recipe (VS Code LaTeX Workshop style)'
    )
    parser.add_argument(
        '--watch', '-w',
        action='store_true',
        help='Enable continuous compilation (watch mode)'
    )
    parser.add_argument(
        '--biber', '-b',
        action='store_true',
        help='Use biber for bibliography processing'
    )
    parser.add_argument(
        '--clean',
        action='store_true',
        help='Clean auxiliary files'
    )
    parser.add_argument(
        '--clean-all',
        action='store_true',
        help='Clean all generated files including PDF'
    )

    args = parser.parse_args()

    # Validate input file
    tex_path = Path(args.tex_file)
    if not tex_path.exists():
        print(f"[ERROR] File not found: {args.tex_file}")
        sys.exit(1)

    if not tex_path.suffix == '.tex':
        print(f"[WARNING] File does not have .tex extension: {args.tex_file}")

    # Create compiler instance
    compiler = LaTeXCompiler(args.tex_file, args.compiler, args.recipe)

    # Execute requested action
    if args.clean or args.clean_all:
        sys.exit(compiler.clean(full=args.clean_all))
    else:
        sys.exit(compiler.compile(watch=args.watch, biber=args.biber))


if __name__ == '__main__':
    main()
